package com.jason.jasonutils.arrayoperate;

import java.util.Arrays;

/**
 * 传说中的数组排序：选择排序和冒泡排序；
 * ==============================================================================================================
 * 选择排序:
 * 
 * 选择排序的实质，就是找最小的，放在左边；再找次小的，放到第二位；再找...
 * 先用零角标元素和之后的元素逐一比较，遇到比他小的，与其交换值，再继续比较；一轮完成后，零角标元素就变成了最小的元素；
 * 再用一角标元素与之后的元素逐一比较，...一轮完成后，一角标元素就是第二小的元素；...如此继续...
 * 当剩下最后一个元素时，不用比较，它已经是最大元素了。
 * 
 * 备注：
 * 选择排序：外循环中的变量是几，就是第几角标元素在和剩下的元素比较；也表示已经进行了几轮比较；
 * for(int x=0;x<arr.length-1;x++)
 * for(int y=x+1;y<arr.length;y++)
 * 每次比较 arr[x]和arr[y]
 * ==============================================================================================================
 * 冒泡排序：
 * 
 * 冒泡排序实质：第一个和第二个比，第二个和第三个比，第三个和第四个比，...
 * 比的过程中如前一个比后一个大，则互换值；..一轮完成，最后一个就是所有元素中最大值；
 * 再从第一个和第二个比，第二和第三比，...倒数第三个和倒数第二比；这一轮完成后，倒数第二个就是所有元素中仅比最后一个小的元素；
 * 这样从后到前，元素依次变小；当剩下第一个元素时候，就不用比较了，已经是最小的元素了；
 * 
 * 备注：
 * 冒泡排序：外循环变量仅仅代表比较多少轮；真正比较的是内循环的相邻两个值；
 * for(int x=0;x<arr.length-1;x++)
 * for(int y=0;y<arr.length-1-x;y++)
 * 每次比较 arr[y]和arr[y+1]
 * ==============================================================================================================
 * 
 * 两种排序方式的比较：效率一样；
 * 从内外循环参数看出：都进行了从0到x<arr.length-1轮的比较；
 * 但是从内循环来看：
 * 选择排序每一轮的比较中，比较次数也在减少：y=x+1;y<arr.length；每轮开始元素逐渐向后推移；因为前面小值已经排定；
 * 冒泡比较每一轮的比较个数逐渐较少；y=0;y<arr.length-1-x；每轮结束元素逐渐向前缩短，因为后面大值已经排定；
 * ==============================================================================================================
 */

public class ArraySort {

	public static void main(String[] args) {
		int arr[]= new int[]{22,33,4,34,19,82,9,94,48};
		readArray(arr);
		selectSort(arr);//选择排序。
		bubbleSort(arr);//冒泡排序。
		Arrays.sort(arr);//java自带的排序方法：Arrays类中的sort()方法。
		readArray(arr);
	}

	
	/**
	 * 选择排序:
	 * 选择排序的实质，就是找最小的，放在左边；再找次小的，放到第二位；再找...
	 * 先用零角标元素和之后的元素逐一比较，遇到比他小的，与其交换值，再继续比较；一轮完成后，零角标元素就变成了最小的元素；
	 * 再用一角标元素与之后的元素逐一比较，...一轮完成后，一角标元素就是第二小的元素；...如此继续...
	 * 当剩下最后一个元素时，不用比较，它已经是最大元素了。
	 * @param arr
	 */
	
	private static void selectSort(int[] arr) {
		for(int x=0;x<arr.length-1;x++) {
			for(int y=x+1;y<arr.length;y++) {
				if(arr[x]>arr[y]) {
					swapArray(arr,x,y);
				}
			}
		}	
	}

	/**
	 * 冒泡排序：
	 * 冒泡排序实质：第一个和第二个比，第二个和第三个比，第三个和第四个比，...
	 * 比的过程中如前一个比后一个大，则互换值；..一轮完成，最后一个就是所有元素中最大值；
	 * 在从一个和第二个比，第二和第三比，...倒数第三个和倒数第二比；(不用和最后一个比)；这一轮完成后，倒数第二个就是所有元素中仅次最后一个小的元素；
	 * 这样从后到前，元素依次变小；当剩下第一个元素时候，就不用比较了，已经是最小的元素了；
	 * @param arr
	 */
	
	private static void bubbleSort(int[] arr) {		
		for(int x=0;x<arr.length-1;x++) {
			for(int y=0;y<arr.length-1-x;y++) {
				if(arr[y]>arr[y+1]) {
					swapArray(arr,y,y+1);					
				}
			}
		}
	}
	
	
	/**
	 * 对于给定的数组，交换指定的两个角标的元素
	 * @param arr
	 * @param i
	 * @param j
	 */
	private static void swapArray(int[] arr, int i, int j) {
		int temp=arr[i];
		arr[i]=arr[j];
		arr[j]=temp;
	}

	/**
	 * 读取给定数组的每个元素（也可以使用StringBuffer来存储，最后toString一把）
	 * @param arr
	 */
	public static void readArray(int arr[]) {
		for(int i=0;i<arr.length;i++) {
		   if(i==0)
			   System.out.print("arr["+arr[i]+",");
		   else if(0<i & i<arr.length-1)
			   System.out.print(arr[i]+",");
		   else
			   System.out.print(arr[i]+"]");
		}	
		System.out.println();
	}
}
